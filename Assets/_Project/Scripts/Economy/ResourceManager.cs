using UnityEngine;

namespace KawaiiCandyBox.Economy
{
    /// <summary>
    /// Tracks all player resources and handles passive generation.
    /// 
    /// Resources managed:
    ///   - Candy (primary currency, generates passively)
    ///   - Lollipops (secondary currency, generated by farm)
    ///   - Eaten candy total (drives HP scaling formula)
    ///
    /// All resource values are kept in sync with SaveManager.Data
    /// so they are always ready to be persisted.
    /// </summary>
    public class ResourceManager : Core.SingletonManager<ResourceManager>
    {
        // ── Candy generation ─────────────────────────────────────────

        // Base rate before any upgrades. Pulled from EconomyConfig
        // once that ScriptableObject exists. Hardcoded for now.
        private const float BaseCandyPerSecond = 1f;

        // Accumulator for partial candy — we generate in float
        // precision but store whole candies
        private float _candyAccumulator = 0f;

        // Current effective CPS including all bonuses.
        // Will be recalculated when upgrades are applied.
        private float _currentCandyPerSecond = BaseCandyPerSecond;

        // ── Offline progression ──────────────────────────────────────
        private long _pendingOfflineCandy = 0;

        // ── Events ───────────────────────────────────────────────────

        // Fired whenever candy count changes — UI subscribes to this
        public static event System.Action<long> OnCandyChanged;

        // Fired whenever lollipop count changes
        public static event System.Action<long> OnLollipopChanged;

        // Fired when offline earnings are ready to be shown
        public static event System.Action<long, long> OnOfflineEarningsReady;
        // Parameters: candyEarned, secondsElapsed

        // ── Properties ───────────────────────────────────────────────

        public long CandyCount      => Core.SaveManager.Instance.Data.candyCount;
        public long LollipopCount   => Core.SaveManager.Instance.Data.lollipopCount;
        public long CandyEatenTotal => Core.SaveManager.Instance.Data.candyEatenTotal;
        public float CandyPerSecond => _currentCandyPerSecond;

        // ── Initialisation ───────────────────────────────────────────

        protected override void OnInitialise()
        {
            Debug.Log("[ResourceManager] Initialised.");
        }

        /// <summary>
        /// Called by GameManager after save data is loaded.
        /// Applies any offline earnings that accrued since last session.
        /// </summary>
        public void OnSaveLoaded()
        {
            long offlineSeconds = Core.SaveManager.Instance.ConsumePendingOfflineSeconds();

            if (offlineSeconds > 0)
            {
                long candyEarned = CalculateOfflineCandy(offlineSeconds);
                _pendingOfflineCandy = candyEarned;

                Debug.Log($"[ResourceManager] Offline earnings ready: " +
                          $"{candyEarned} candy over {offlineSeconds}s.");

                // Fire event so UI can show the welcome-back screen.
                // Actual candy is added when player taps Collect.
                OnOfflineEarningsReady?.Invoke(candyEarned, offlineSeconds);
            }
        }

        /// <summary>
        /// Called by the welcome-back screen's Collect button.
        /// Adds pending offline candy to the player's total.
        /// </summary>
        public void CollectOfflineEarnings()
        {
            if (_pendingOfflineCandy <= 0) return;

            AddCandy(_pendingOfflineCandy);
            _pendingOfflineCandy = 0;
            Debug.Log("[ResourceManager] Offline earnings collected.");
        }

        // ── Update loop ──────────────────────────────────────────────

        private void Update()
        {
            GeneratePassiveCandy();
        }

        private void GeneratePassiveCandy()
        {
            _candyAccumulator += _currentCandyPerSecond * Time.deltaTime;

            if (_candyAccumulator >= 1f)
            {
                long wholeCandy = (long)_candyAccumulator;
                _candyAccumulator -= wholeCandy;
                AddCandy(wholeCandy);
            }
        }

        // ── Public candy API ─────────────────────────────────────────

        /// <summary>
        /// Adds candy to the player's total and fires OnCandyChanged.
        /// </summary>
        public void AddCandy(long amount)
        {
            if (amount <= 0) return;

            Core.SaveManager.Instance.Data.candyCount += amount;
            OnCandyChanged?.Invoke(CandyCount);
        }

        /// <summary>
        /// Attempts to spend the given amount of candy.
        /// Returns true and deducts the amount if the player can afford it.
        /// Returns false and changes nothing if they cannot.
        /// </summary>
        public bool TrySpendCandy(long amount)
        {
            if (amount <= 0) return true;

            if (Core.SaveManager.Instance.Data.candyCount < amount)
                return false;

            Core.SaveManager.Instance.Data.candyCount -= amount;
            OnCandyChanged?.Invoke(CandyCount);
            return true;
        }

        /// <summary>
        /// Player eats all current candy.
        /// Resets candy count to 0, adds to eaten total,
        /// and notifies GameManager to recalculate max HP.
        /// </summary>
        public void EatAllCandy()
        {
            long eaten = CandyCount;
            if (eaten <= 0) return;

            Core.SaveManager.Instance.Data.candyEatenTotal += eaten;
            Core.SaveManager.Instance.Data.candyCount = 0;

            OnCandyChanged?.Invoke(0);

            // Tell GameManager to recalculate HP based on new eaten total
            Core.GameManager.Instance.OnCandyEaten(
                Core.SaveManager.Instance.Data.candyEatenTotal
            );

            Debug.Log($"[ResourceManager] Ate {eaten} candy. " +
                      $"Total eaten: {CandyEatenTotal}.");
        }

        /// <summary>
        /// Throws 10 candies on the ground (spends them with no return).
        /// Returns false if the player doesn't have enough.
        /// </summary>
        public bool ThrowCandy(long amount = 10)
        {
            if (!TrySpendCandy(amount))
            {
                Debug.Log("[ResourceManager] Not enough candy to throw.");
                return false;
            }

            Debug.Log($"[ResourceManager] Threw {amount} candy on the ground.");
            return true;
        }

        // ── Public lollipop API ──────────────────────────────────────

        /// <summary>
        /// Adds lollipops to the player's total.
        /// </summary>
        public void AddLollipops(long amount)
        {
            if (amount <= 0) return;

            Core.SaveManager.Instance.Data.lollipopCount += amount;
            OnLollipopChanged?.Invoke(LollipopCount);
        }

        /// <summary>
        /// Attempts to spend the given number of lollipops.
        /// Returns true and deducts if affordable, false otherwise.
        /// </summary>
        public bool TrySpendLollipops(long amount)
        {
            if (amount <= 0) return true;

            if (Core.SaveManager.Instance.Data.lollipopCount < amount)
                return false;

            Core.SaveManager.Instance.Data.lollipopCount -= amount;
            OnLollipopChanged?.Invoke(LollipopCount);
            return true;
        }

        // ── CPS management ───────────────────────────────────────────

        /// <summary>
        /// Recalculates effective CPS from base rate plus all bonuses.
        /// Call this whenever an upgrade is purchased that affects CPS.
        /// </summary>
        public void RecalculateCandyPerSecond(float bonusCps = 0f)
        {
            // TODO: Factor in mill upgrades and other bonuses
            // when those systems exist
            _currentCandyPerSecond = BaseCandyPerSecond + bonusCps;
            Debug.Log($"[ResourceManager] CPS updated: {_currentCandyPerSecond}");
        }

        // ── Offline calculation ──────────────────────────────────────

        private long CalculateOfflineCandy(long seconds)
        {
            // TODO: Replace hardcoded 1.0f with EconomyConfig.OfflineRate
            // once EconomyConfig ScriptableObject exists
            const float offlineRate = 1.0f;
            return (long)(_currentCandyPerSecond * offlineRate * seconds);
        }
    }
}
