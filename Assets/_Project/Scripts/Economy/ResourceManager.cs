using UnityEngine;

namespace KawaiiCandyBox.Economy
{
    /// <summary>
    /// Tracks all player resources and handles passive generation.
    /// 
    /// Resources managed:
    ///   - Candy (primary currency, generates passively)
    ///   - Lollipops (secondary currency, generated by farm)
    ///   - Eaten candy total (drives HP scaling formula)
    ///
    /// All resource values are kept in sync with SaveManager.Data
    /// so they are always ready to be persisted.
    /// </summary>
    public class ResourceManager : Core.SingletonManager<ResourceManager>
    {
        // ── Config ───────────────────────────────────────────────────
        [SerializeField] private EconomyConfig _economyConfig;

        // ── Candy generation ─────────────────────────────────────────
        private const float BaseCandyPerSecond = 1f;
        //private const long ChocolateBarThreshold = 1630;
        private long ChocolateBarThreshold => _economyConfig != null
        ? _economyConfig.chocolateBarThreshold
        : 1630L;

        // Accumulator for partial candy — we generate in float
        // precision but store whole candies
        private float _candyAccumulator = 0f;

        // Current effective CPS including all bonuses.
        // Will be recalculated when upgrades are applied.
        private float _currentCandyPerSecond = BaseCandyPerSecond;

        // ── Offline progression ──────────────────────────────────────
        private long _pendingOfflineCandy = 0;

        // ── Events ───────────────────────────────────────────────────

        // Fired whenever candy count changes
        public static event System.Action<long> OnCandyChanged;

        // Fired whenever lollipop count changes
        public static event System.Action<long> OnLollipopChanged;

        // Fired whenever chocolate bar count changes
        public static event System.Action<int> OnChocolateBarChanged;

        // Fired when candy is thrown
        // Parameters: totalCandiesThrown, justEarnedChocolateBar
        public static event System.Action<long, bool> OnCandyThrown;

        // Fired when a chocolate bar is earned
        public static event System.Action OnChocolateBarEarned;

        // Fired when offline earnings are ready to be shown
        // Parameters: candyEarned, secondsElapsed
        public static event System.Action<long, long> OnOfflineEarningsReady;

        // ── Properties ───────────────────────────────────────────────

        public long CandyCount      => Core.SaveManager.Instance.Data.candyCount;
        public long LollipopCount   => Core.SaveManager.Instance.Data.lollipopCount;
        public long CandyEatenTotal => Core.SaveManager.Instance.Data.candyEatenTotal;
        public float CandyPerSecond => _currentCandyPerSecond;

        public long OfflineCapSeconds => _economyConfig != null
            ? (long)(_economyConfig.offlineCapHours * 3600f)
            : 28800L;

        // ── Initialisation ───────────────────────────────────────────

        protected override void OnInitialise()
        {
            if (_economyConfig != null)
            {
                _currentCandyPerSecond = _economyConfig.baseCandyPerSecond;

                #if UNITY_EDITOR
                _currentCandyPerSecond *= _economyConfig.debugCpsMultiplier;
                #endif
            }

            Debug.Log($"[ResourceManager] Initialised. CPS: {_currentCandyPerSecond}");
        }

        /// <summary>
        /// Called by GameManager after save data is loaded.
        /// Applies any offline earnings that accrued since last session.
        /// </summary>
        public void OnSaveLoaded()
        {
            long offlineSeconds = Core.SaveManager.Instance.ConsumePendingOfflineSeconds();

            if (offlineSeconds > 0)
            {
                long candyEarned = CalculateOfflineCandy(offlineSeconds);
                _pendingOfflineCandy = candyEarned;

                Debug.Log($"[ResourceManager] Offline earnings ready: " +
                          $"{candyEarned} candy over {offlineSeconds}s.");

                OnOfflineEarningsReady?.Invoke(candyEarned, offlineSeconds);
            }
        }

        /// <summary>
        /// Called by the welcome-back screen's Collect button.
        /// Adds pending offline candy to the player's total.
        /// </summary>
        public void CollectOfflineEarnings()
        {
            if (_pendingOfflineCandy <= 0) return;

            AddCandy(_pendingOfflineCandy);
            _pendingOfflineCandy = 0;
            Debug.Log("[ResourceManager] Offline earnings collected.");
        }

        // ── Update loop ──────────────────────────────────────────────

        private void Update()
        {
            GeneratePassiveCandy();
        }

        private void GeneratePassiveCandy()
        {
            _candyAccumulator += _currentCandyPerSecond * Time.deltaTime;

            if (_candyAccumulator >= 1f)
            {
                long wholeCandy = (long)_candyAccumulator;
                _candyAccumulator -= wholeCandy;
                AddCandy(wholeCandy);
            }
        }

        // ── Public candy API ─────────────────────────────────────────

        /// <summary>
        /// Adds candy to the player's total and fires OnCandyChanged.
        /// </summary>
        public void AddCandy(long amount)
        {
            if (amount <= 0) return;

            Core.SaveManager.Instance.Data.candyCount += amount;
            OnCandyChanged?.Invoke(CandyCount);
        }

        /// <summary>
        /// Attempts to spend the given amount of candy.
        /// Returns true and deducts the amount if the player can afford it.
        /// Returns false and changes nothing if they cannot.
        /// </summary>
        public bool TrySpendCandy(long amount)
        {
            if (amount <= 0) return true;

            if (Core.SaveManager.Instance.Data.candyCount < amount)
                return false;

            Core.SaveManager.Instance.Data.candyCount -= amount;
            OnCandyChanged?.Invoke(CandyCount);
            return true;
        }

        /// <summary>
        /// Player eats all current candy.
        /// Resets candy count to 0, adds to eaten total,
        /// and notifies GameManager to recalculate max HP.
        /// </summary>
        public void EatAllCandy()
        {
            long eaten = CandyCount;
            if (eaten <= 0) return;

            Core.SaveManager.Instance.Data.candyEatenTotal += eaten;
            Core.SaveManager.Instance.Data.candyCount = 0;

            OnCandyChanged?.Invoke(0);

            Core.GameManager.Instance.OnCandyEaten(
                Core.SaveManager.Instance.Data.candyEatenTotal
            );
            Core.SaveManager.Instance.SaveGame();
            Debug.Log($"[ResourceManager] Ate {eaten} candy. " +
                      $"Total eaten: {CandyEatenTotal}.");
        }

        /// <summary>
        /// Throws candies on the ground. Awards chocolate bar
        /// when total thrown crosses the threshold.
        /// Returns false if the player doesn't have enough candy.
        /// </summary>
        public bool ThrowCandy(long amount = 10)
        {
            if (!TrySpendCandy(amount))
            {
                Debug.Log("[ResourceManager] Not enough candy to throw.");
                return false;
            }

            Core.SaveManager.Instance.Data.totalCandiesThrown += amount;
            long totalThrown = Core.SaveManager.Instance.Data.totalCandiesThrown;

            bool justEarnedChocolate =
                totalThrown >= ChocolateBarThreshold &&
                totalThrown - amount < ChocolateBarThreshold;

            if (justEarnedChocolate)
            {
                Core.SaveManager.Instance.Data.chocolateBarCount++;
                Core.SaveManager.Instance.Data.hasSeenChocolateBars = true;
                Debug.Log("[ResourceManager] Chocolate bar earned!");
                OnChocolateBarEarned?.Invoke();
                OnChocolateBarChanged?.Invoke(
                    Core.SaveManager.Instance.Data.chocolateBarCount);
            }

            Debug.Log($"[ResourceManager] Threw {amount} candy. " +
                      $"Total thrown: {totalThrown}.");

            OnCandyThrown?.Invoke(totalThrown, justEarnedChocolate);
            Core.SaveManager.Instance.SaveGame();
            return true;
        }

        // ── Public lollipop API ──────────────────────────────────────

        /// <summary>
        /// Adds lollipops to the player's total.
        /// </summary>
        public void AddLollipops(long amount)
        {
            if (amount <= 0) return;

            Core.SaveManager.Instance.Data.lollipopCount += amount;
            OnLollipopChanged?.Invoke(LollipopCount);
        }

        /// <summary>
        /// Attempts to spend the given number of lollipops.
        /// Returns true and deducts if affordable, false otherwise.
        /// </summary>
        public bool TrySpendLollipops(long amount)
        {
            if (amount <= 0) return true;

            if (Core.SaveManager.Instance.Data.lollipopCount < amount)
                return false;

            Core.SaveManager.Instance.Data.lollipopCount -= amount;
            OnLollipopChanged?.Invoke(LollipopCount);
            return true;
        }

        // ── CPS management ───────────────────────────────────────────

        /// <summary>
        /// Recalculates effective CPS from base rate plus all bonuses.
        /// Call this whenever an upgrade is purchased that affects CPS.
        /// </summary>
        public void RecalculateCandyPerSecond(float bonusCps = 0f)
        {
            // TODO: Factor in mill upgrades and other bonuses
            // when those systems exist
            _currentCandyPerSecond = BaseCandyPerSecond + bonusCps;
            Debug.Log($"[ResourceManager] CPS updated: {_currentCandyPerSecond}");
        }

        // ── Offline calculation ──────────────────────────────────────

        private long CalculateOfflineCandy(long seconds)
        {
            float rate = _economyConfig != null
                ? _economyConfig.offlineCandyRate
                : 1f;
            return (long)(_currentCandyPerSecond * rate * seconds);
        }
    }
}